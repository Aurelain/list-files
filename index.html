<!DOCTYPE html>
<html lang='en'>
    <head>
        <meta charset='UTF-8'>
        <meta name='viewport' content='width=device-width, initial-scale=1.0'>
        <link rel='icon' type='image/svg+xml' href="data:image/svg+xml,
            <svg xmlns='http://www.w3.org/2000/svg'><text y='24' font-size='24'>üíº</text></svg>">
        <title>manage-files</title>
        <style>
            html, body {
                margin: 0;
                font-family: sans-serif;
                font-size: 14px;
                cursor: default;
                image-rendering: pixelated;
            }

            button, input {
                font-size: inherit;
                font-family: inherit;
            }

            button {
                user-select: none;
                cursor: pointer;
                outline: none;
                background: papayawhip;
                border: 0;
                padding: 2px 4px;
                margin: 0 2px;
                font-size: inherit;
                border-radius: 4px;
            }

            button:hover {
                background: yellow;
            }

            button:active {
                background: orange;
            }

            button[disabled] {
                cursor: default;
                opacity: 0.5;
                background: papayawhip;
            }

            /*noinspection CssInvalidFunction*/
            dialog {
                border-width: 1px;
                padding: 24px 24px 32px 24px;
                min-width: 320px;
                left: round(50%, 1px);
                top: round(50%, 1px);
                transform: translate(
                        round(-50%, 1px),
                        round(-50%, 1px)
                );
                margin: 0;
            }

            li {
                margin-block: 4px;
                list-style-type: none;
                user-select: none;
            }

            .close {
                position: absolute;
                top: 0;
                right: 0;
                border: 0;
                width: 32px;
                height: 24px;
                color: white;
                background: #f008;
                padding: 0;
                margin: 0;
            }

            .close:hover {
                background: #f00;
            }

            .close:active {
                background: #000;
            }

            #file-list {
                padding-top: 48px;
            }

            table {
                width: 100%;
                border-collapse: collapse;
            }

            tr {
                border-bottom: 1px solid #ccc;
            }

            td {
                padding: 4px 0 8px 0;
            }

            .wrapper {
                cursor: pointer;
                padding: 4px;
                margin-left: -1px;
            }

            .wrapper:hover {
                background: rgba(31, 158, 222, 0.5);
            }

            .wrapper-image {
                display: inline-block;
                padding: 1px 1px 4px 1px;
            }

            img {
                min-height: 32px;
                min-width: 32px;
                max-height: 256px;
                max-width: 256px;
                user-select: none;
            }

            .selected {
                background: #1f9ede;
                color: #fff;
                position: relative;
            }

            .selected:hover {
                background: #0870a5;
            }

            .wrapper:active, .selected:active {
                color: #fff;
                background: #000;
            }

            .selected::before {
                content: "‚òëÔ∏è";
                position: absolute;
                right: 4px;
                top: 4px;
                font-size: 18px;
                width: 24px;
                height: 24px;
                background: white;
                text-align: center;
                line-height: 24px;
            }

            #toolbar {
                position: fixed;
                inset: 0;
                bottom: auto;
                background: saddlebrown;
                padding: 4px 2px;
                display: flex;
                color: white;
            }

            #file-count {
                margin: 0 2px;
                line-height: 24px;
            }

            .modal-title {
                margin-top: 0;
            }

            .modal-footer {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                text-align: right;
                background: saddlebrown;
                padding: 4px;
            }

            #input-filters {
                border: 0;
                padding: 1px 4px;
                flex-grow: 1;
                margin: 0 2px;
                outline-offset: 2px;
                outline-color: orange;
            }

            /*noinspection CssUnusedSymbol*/
            #input-filters.invalid {
                background: pink;
            }

            /*noinspection CssUnusedSymbol*/
            .hidden {
                display: none !important;
            }
        </style>
    </head>
    <body>

        <div id='toolbar'>
            <button id='roots-show'>Roots <span id='roots-warning'>‚ö†Ô∏è</span></button>
            <input id='input-filters' type='text' title='Filters' spellcheck='false' autocomplete='off'>
            <div id='file-count'>Selected: <span id='selected-count'>0</span>/<span id='total-count'>0</span></div>
            <button id='select-all' disabled>Select all</button>
            <button id='duplicate-files' disabled>Duplicate</button>
            <button id='move-files' disabled>Move</button>
            <button id='delete-files' disabled>Delete</button>
        </div>

        <dialog id='roots-modal'>
            <h2 class='modal-title'>Roots</h2>
            <button class='close'>√ó</button>

            <ul id='roots-list'></ul>
            <div class='modal-footer'>
                <button id='roots-add'>Add</button>
                <button id='roots-renew' disabled>Renew</button>
            </div>
        </dialog>

        <div id='file-list'></div>

        <script>
            // =========================================================================================================
            // D E C L A R A T I O N S
            // =========================================================================================================
            const DB_NAME = window.location.host || 'localhost';
            const STORE_NAME = 'store';
            const ROOTS = 'roots';
            const rootsModal = query('#roots-modal');
            const rootsList = query('#roots-list');
            const rootsRenew = query('#roots-renew');
            const rootsWarning = query('#roots-warning');
            const inputFilters = query('#input-filters');
            const fileList = query('#file-list');
            const selectedCount = query('#selected-count');
            const totalCount = query('#total-count');
            let ast; // abstract-syntax-tree

            // =========================================================================================================
            // M A I N
            // =========================================================================================================
            /**
             *
             */
            async function main() {
                // Toolbar:
                on('click', '#roots-show', rootsModal.showModal.bind(rootsModal));
                on('contextmenu', '#roots-show', onRootsRenewClick);

                // Modals:
                on('click', '.close', (e) => e.currentTarget.closest('dialog').close());

                // Roots:
                on('click', '#roots-add', onRootsAddClick);
                on('click', rootsRenew, onRootsRenewClick);
                await populateRoots();
                // rootsModal.showModal();

                // Filters:
                inputFilters.value = window.location.hash.substring(1);
                on('input', inputFilters, checkFilter);
                on('change', inputFilters, onFiltersChange);
                on('hashchange', window, onHashChange);
                checkFilter();
                await render();

            }

            main();

            // =========================================================================================================
            // Render
            // =========================================================================================================
            /**
             *
             */
            async function render() {
                const ast = buildAst(inputFilters.value);
                const list = await findFiles(ast);
                const sorted = sortNaturally(list);
                const grouped = groupByStem(sorted);
                populateFileList(grouped);
            }

            /**
             *
             */
            async function findFiles(ast) {
                const roots = await getRoots();
                const output = [];
                for (const {handle} of roots) {
                    output.push(...await findInDirectory(handle, ast));
                }
                return output;
            }

            /**
             *
             */
            async function findInDirectory(dirHandle, ast, currentPath = '') {
                const output = [];
                const entries = await getFiles(dirHandle);
                for (const [name, handle] of entries) {
                    const fullPath = `${currentPath}/${name}`;
                    if (!ast || evaluateNode(ast, fullPath)) {
                        if (handle.kind === 'directory') {
                            output.push(...await findInDirectory(handle, null, fullPath));
                        } else {
                            output.push({
                                file: await handle.getFile(),
                                path: fullPath,
                            });
                        }
                    } else {
                        if (handle.kind === 'directory') {
                            output.push(...await findInDirectory(handle, ast, fullPath));
                        }
                    }
                }
                return output;
            }

            /**
             *
             */
            async function getFiles(dirHandle) {
                const entries = [];
                try {
                    for await (const entry of dirHandle.entries()) {
                        entries.push(entry);
                    }
                } catch (error) {
                }
                return entries;
            }

            /**
             *
             */
            function groupByStem(list) {
                const map = {};
                const output = [];
                for (const item of list) {
                    const stem = item.path.split('/').pop().replace(/\.[^.]*$/, '');
                    if (!map[stem]) {
                        map[stem] = [];
                        output.push(map[stem]);
                    }
                    map[stem].push(item);
                }
                return output;
            }

            /**
             *
             */
            function populateFileList(groups) {
                if (!groups.length) {
                    fileList.innerHTML = '&nbsp;No results.';
                    totalCount.innerHTML = '0';
                    return;
                }
                fileList.innerHTML = '';
                const table = document.createElement('table');
                const tableBody = document.createElement('tbody');
                table.appendChild(tableBody);
                let count = 0;
                for (const group of groups) {
                    const [first] = group;
                    const {path} = first;
                    count += group.length;
                    const tr = document.createElement('tr');
                    const td = document.createElement('td');

                    const wrapper = buildWrapper(path);
                    wrapper.innerHTML = path;
                    td.appendChild(wrapper);

                    if (first.path.match(/jpg$|png$|jpeg$|webp$|gif$/i)) {
                        td.appendChild(buildGroup(group));
                    }

                    tr.appendChild(td);
                    tableBody.appendChild(tr);
                }
                fileList.appendChild(table);
                totalCount.innerHTML = count.toString();
            }

            /**
             *
             */
            function buildWrapper(path) {
                const wrapper = document.createElement('div');
                wrapper.title = path;
                wrapper.classList.add('wrapper');
                on('click', wrapper, onWrapperClick);
                return wrapper;
            }

            /**
             *
             */
            function buildGroup(group) {
                const div = document.createElement('div');
                for (const {file, path} of group) {
                    const wrapper = buildWrapper(path);
                    wrapper.classList.add('wrapper-image');
                    const img = convertFileToImgElement(file);
                    img.draggable = false;
                    img.alt = path;
                    wrapper.appendChild(img);
                    div.appendChild(wrapper);
                }
                return div;
            }

            /**
             *
             */
            function convertFileToImgElement(file) {
                const img = document.createElement('img');
                const url = URL.createObjectURL(file);
                img.src = url;
                img.onload = () => URL.revokeObjectURL(url); // clean up the object URL once the image is loaded
                return img;
            }

            /**
             *
             */
            function onWrapperClick(event) {
                event.currentTarget.classList.toggle('selected');
                const allSelected = queryAll('.selected');
                selectedCount.innerHTML = allSelected.length.toString();
            }


            // =========================================================================================================
            // Roots
            // =========================================================================================================
            /**
             *
             */
            async function getRoots() {
                return await readFromDb(ROOTS) || [];
            }

            /**
             *
             */
            async function populateRoots() {
                const roots = await getRoots();
                const markups = [];
                let failed = 0;
                for (const {handle} of roots) {
                    // noinspection JSUnresolvedReference
                    const isGranted = await handle.queryPermission() === 'granted';
                    failed += isGranted ? 0 : 1;
                    const symbol = isGranted ? '‚úÖÔ∏è' : '‚ö†Ô∏è';
                    markups.push(`<li>${symbol} <button title='Click to remove'>${handle.name}</button></li>`);
                }
                rootsList.innerHTML = markups.join('');
                rootsRenew.disabled = !failed;
                hide(rootsWarning, roots.length && !failed);
                on('click', '#roots-list button', onRootsHandleClick);
            }

            /**
             *
             */
            async function onRootsAddClick() {
                let dirHandle;
                try {
                    // noinspection JSUnresolvedReference
                    dirHandle = await window.showDirectoryPicker({mode: 'readwrite'});
                } catch (e) {
                }
                if (dirHandle) {
                    const roots = await getRoots();
                    roots.push({
                        handle: dirHandle,
                    });
                    await writeToDb(ROOTS, roots);
                    await populateRoots();
                }
            }

            /**
             *
             */
            async function onRootsRenewClick(event) {
                event.preventDefault(); // for context menu
                const roots = await getRoots();
                for (const {handle} of roots) {
                    await handle.requestPermission();
                }
                await populateRoots();
            }

            /**
             *
             */
            async function onRootsHandleClick(event) {
                const allHandleButtons = Array.from(rootsList.querySelectorAll('button'));
                const index = allHandleButtons.indexOf(event.currentTarget);
                const roots = await getRoots();
                roots.splice(index, 1);
                await writeToDb(ROOTS, roots);
                await populateRoots();
            }

            // =========================================================================================================
            // Filters
            // =========================================================================================================
            /**
             *
             */
            function checkFilter() {
                ast = buildAst(inputFilters.value);
                inputFilters.classList.toggle('invalid', !ast);
            }

            /**
             *
             */
            function onFiltersChange(event) {
                const {value} = event.currentTarget;
                const hash = window.location.hash.substring(1);
                if (value !== hash) {
                    window.location.hash = value;
                    render();
                }
            }

            /**
             *
             */
            function onHashChange() {
                const hash = window.location.hash.substring(1);
                if (hash !== inputFilters.value) {
                    inputFilters.value = hash;
                    checkFilter();
                    render();
                }
            }

            // =========================================================================================================
            // IndexedDB
            // =========================================================================================================
            /**
             *
             */
            function openDB() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(DB_NAME);
                    req.onupgradeneeded = e => e.target.result.createObjectStore(STORE_NAME);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            }

            /**
             *
             */
            function deleteDatabase() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.deleteDatabase(DB_NAME);
                    req.onsuccess = () => {
                        resolve();
                        console.log('Database deleted successfully.');
                    };
                    req.onerror = () => reject(req.error);
                    req.onblocked = () => console.warn('Database deletion blocked.');
                });
            }


            /**
             *
             */
            async function readFromDb(key) {
                const dbs = await indexedDB.databases();
                if (!dbs.find(db => db.name === DB_NAME)) {
                    return;
                }
                const db = await openDB();
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.close();
                    return;
                }
                return new Promise((resolve, reject) => {
                    const request = db.transaction(STORE_NAME).objectStore(STORE_NAME).get(key);
                    request.onsuccess = () => {
                        resolve(request.result);
                        db.close();
                    };
                    request.onerror = () => {
                        reject(request.error);
                        db.close();
                    };
                });
            }

            /**
             *
             */
            async function writeToDb(key, value) {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_NAME, 'readwrite');
                    tx.objectStore(STORE_NAME).put(value, key);
                    tx.oncomplete = () => {
                        resolve();
                        db.close();
                    };
                    tx.onerror = () => {
                        reject(tx.error);
                        db.close();
                    };
                });
            }

            // =========================================================================================================
            // Parser
            // =========================================================================================================
            /**
             *
             */
            function buildAst(input) {
                // Matches (, ), &, |, or sequences of other characters
                const tokens = input.match(/\(|\)|&|\||[^()|&]+/g) || [];

                const parser = new LogicalParser(tokens);
                try {
                    return parser.parse();
                } catch (e) {
                    console.error(e);
                }
            }

            /**
             * AI Generated
             */
            class LogicalParser {
                constructor(tokens) {
                    this.tokens = tokens;
                    this.pos = 0;
                }

                parse() {
                    return this.parseOr();
                }

                // Handles '|' (lowest priority)
                parseOr() {
                    let node = this.parseAnd();
                    while (this.peek() === '|') {
                        this.consume('|');
                        node = {type: 'OR', left: node, right: this.parseAnd()};
                    }
                    return node;
                }

                // Handles '&'
                parseAnd() {
                    let node = this.parsePrimary();
                    while (this.peek() === '&') {
                        this.consume('&');
                        node = {type: 'AND', left: node, right: this.parsePrimary()};
                    }
                    return node;
                }

                // Handles parentheses and raw words (highest priority)
                parsePrimary() {
                    const token = this.consume();
                    if (token === '(') {
                        const node = this.parseOr();
                        this.consume(')'); // Clean up the closing paren
                        return node;
                    }

                    return {type: 'WORD', value: new RegExp(token)};
                }

                peek() {
                    return this.tokens[this.pos];
                }

                consume(expected) {
                    const token = this.tokens[this.pos++];

                    // If we expected a specific character, like ')', and didn't get it:
                    if (expected && token !== expected) {
                        throw new Error(`Expected "${expected}"!"`);
                    }

                    return token;
                }
            }

            /**
             * AI Generated
             */
            function evaluateNode(node, targetString) {
                switch (node.type) {
                    case 'WORD':
                        return node.value.test(targetString);

                    case 'AND':
                        // Both sides must be true
                        return evaluateNode(node.left, targetString) && evaluateNode(node.right, targetString);

                    case 'OR':
                        // Only one side needs to be true
                        return evaluateNode(node.left, targetString) || evaluateNode(node.right, targetString);

                    default:
                        throw new Error(`Unknown node type: ${node.type}`);
                }
            }

            // =========================================================================================================
            // Helpers
            // =========================================================================================================
            /**
             *
             */
            function query(selector) {
                return document.querySelector(selector);
            }

            /**
             *
             */
            function queryAll(selector) {
                if (typeof selector === 'string') {
                    return Array.from(document.querySelectorAll(selector));
                } else {
                    return [selector];
                }
            }

            /**
             *
             */
            function on(name, selector, handler) {
                for (const element of queryAll(selector)) {
                    element.addEventListener(name, handler);
                }
            }

            /**
             *
             */
            function hide(selector, force) {
                const value = force === undefined ? true : Boolean(force);
                for (const element of queryAll(selector)) {
                    element.classList.toggle('hidden', value);
                }
            }

            /**
             *
             */
            function sortNaturally(arr) {
                return [...arr].sort((a, b) => {
                    return a.path.localeCompare(b.path, undefined, {
                        numeric: true,
                        sensitivity: 'base'
                    });
                });
            }

        </script>
    </body>
</html>